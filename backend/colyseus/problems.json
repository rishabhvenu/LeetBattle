{
    "search-in-rotated-sorted-array": {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "topics": ["Array", "Binary Search"],
      "examples": [
        {
          "input": " nums = [4,5,6,7,0,1,2], target = 0",
          "output": " 4",
          "explanation": null
        },
        {
          "input": " nums = [4,5,6,7,0,1,2], target = 3",
          "output": " -1",
          "explanation": null
        },
        {
          "input": " nums = [1], target = 0",
          "output": " -1",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 5000</code>",
        "<code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>",
        "All values of <code>nums</code> are <strong>unique</strong>.",
        "<code>nums</code> is an ascending array that is possibly rotated.",
        "<code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code>"
      ],
      "description": "There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).<br /><br />Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.<br /><br />Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.<br /><br />You must write an algorithm with <code>O(log n)</code> runtime complexity.<br /><br />&nbsp;<br /><br />"
    },
    "two-sum": {
      "title": "Two Sum",
      "difficulty": "Easy",
      "topics": ["Array", "Hash Table"],
      "examples": [
        {
          "input": " nums = [2,7,11,15], target = 9",
          "output": " [0,1]",
          "explanation": " Because nums[0] + nums[1] == 9, we return [0, 1]."
        },
        {
          "input": " nums = [3,2,4], target = 6",
          "output": " [1,2]",
          "explanation": null
        },
        {
          "input": " nums = [3,3], target = 6",
          "output": " [0,1]",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code>",
        "<code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>",
        "<code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code>",
        "<strong>Only one valid answer exists.</strong>"
      ],
      "description": "Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.<br /><br />You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.<br /><br />You can return the answer in any order.<br /><br />&nbsp;<br /><br />"
    },
    "best-time-to-buy-and-sell-stock": {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "topics": ["Array", "Dynamic Programming"],
      "examples": [
        {
          "input": " prices = [7,1,5,3,6,4]",
          "output": " 5",
          "explanation": " Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n"
        },
        {
          "input": " prices = [7,6,4,3,1]",
          "output": " 0",
          "explanation": " In this case, no transactions are done and the max profit = 0."
        }
      ],
      "constraints": [
        "<code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code>",
        "<code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code>"
      ],
      "description": "You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.<br /><br />You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.<br /><br />Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.<br /><br />&nbsp;<br /><br />"
    },
    "contains-duplicate": {
      "title": "Contains Duplicate",
      "difficulty": "Easy",
      "topics": ["Array", "Hash Table", "Sorting"],
      "examples": [],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>",
        "<code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>"
      ],
      "description": "Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.<br /><br />&nbsp;<br /><br />"
    },
    "product-of-array-except-self": {
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "topics": ["Array", "Prefix Sum"],
      "examples": [
        {
          "input": " nums = [1,2,3,4]",
          "output": " [24,12,8,6]",
          "explanation": null
        },
        {
          "input": " nums = [-1,1,0,-3,3]",
          "output": " [0,0,9,0,0]",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code>",
        "<code>-30 &lt;= nums[i] &lt;= 30</code>",
        "The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer."
      ],
      "description": "Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.<br /><br />The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br /><br />You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.<br /><br />&nbsp;<br /><br />"
    },
    "maximum-subarray": {
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "topics": ["Array", "Divide and Conquer", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": " 6",
          "explanation": " The subarray [4,-1,2,1] has the largest sum 6."
        },
        {
          "input": " nums = [1]",
          "output": " 1",
          "explanation": " The subarray [1] has the largest sum 1."
        },
        {
          "input": " nums = [5,4,-1,7,8]",
          "output": " 23",
          "explanation": " The subarray [5,4,-1,7,8] has the largest sum 23."
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>",
        "<code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>"
      ],
      "description": "Given an integer array <code>nums</code>, find the <span data-keyword=\"subarray-nonempty\" class=\" cursor-pointer relative text-dark-blue-s text-sm\"><div class=\"popover-wrapper inline-block\" data-headlessui-state=\"\"><div><div aria-expanded=\"false\" data-headlessui-state=\"\" id=\"headlessui-popover-button-:r2c:\"><div>subarray</div></div><div style=\"position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(285px, 182px);\"></div></div></div></span> with the largest sum, and return <em>its sum</em>.<br /><br />&nbsp;<br /><br />"
    },
    "maximum-product-subarray": {
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [2,3,-2,4]",
          "output": " 6",
          "explanation": " [2,3] has the largest product 6."
        },
        {
          "input": " nums = [-2,0,-1]",
          "output": " 0",
          "explanation": " The result cannot be 2, because [-2,-1] is not a subarray."
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code>",
        "<code>-10 &lt;= nums[i] &lt;= 10</code>",
        "The product of any subarray of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer."
      ],
      "description": "Given an integer array <code>nums</code>, find a <span data-keyword=\"subarray-nonempty\" class=\" cursor-pointer relative text-dark-blue-s text-sm\"><div class=\"popover-wrapper inline-block\" data-headlessui-state=\"\"><div><div aria-expanded=\"false\" data-headlessui-state=\"\" id=\"headlessui-popover-button-:r2c:\"><div>subarray</div></div><div style=\"position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(272px, 182px);\"></div></div></div></span> that has the largest product, and return <em>the product</em>.<br /><br />The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.<br /><br />&nbsp;<br /><br />"
    },
    "find-minimum-in-rotated-sorted-array": {
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "topics": ["Array", "Binary Search"],
      "examples": [
        {
          "input": " nums = [3,4,5,1,2]",
          "output": " 1",
          "explanation": " The original array was [1,2,3,4,5] rotated 3 times."
        },
        {
          "input": " nums = [4,5,6,7,0,1,2]",
          "output": " 0",
          "explanation": " The original array was [0,1,2,4,5,6,7] and it was rotated 4 times."
        },
        {
          "input": " nums = [11,13,15,17]",
          "output": " 11",
          "explanation": " The original array was [11,13,15,17] and it was rotated 4 times. "
        }
      ],
      "constraints": [
        "<code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.",
        "<code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times."
      ],
      "description": "Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:<br /><br />\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n<br /><br />Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.<br /><br />Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.<br /><br />You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.<br /><br />&nbsp;<br /><br />"
    },
    "3sum": {
      "title": "3Sum",
      "difficulty": "Medium",
      "topics": ["Array", "Two Pointers", "Sorting"],
      "examples": [
        {
          "input": " nums = [-1,0,1,2,-1,-4]",
          "output": " [[-1,-1,2],[-1,0,1]]",
          "explanation": " nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n"
        },
        {
          "input": " nums = [0,1,1]",
          "output": " []",
          "explanation": " The only possible triplet does not sum up to 0."
        },
        {
          "input": " nums = [0,0,0]",
          "output": " [[0,0,0]]",
          "explanation": " The only possible triplet sums up to 0."
        }
      ],
      "constraints": [
        "<code>3 &lt;= nums.length &lt;= 3000</code>",
        "<code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code>"
      ],
      "description": "Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.<br /><br />Notice that the solution set must not contain duplicate triplets.<br /><br />&nbsp;<br /><br />"
    },
    "container-with-most-water": {
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "topics": ["Array", "Two Pointers", "Greedy"],
      "examples": [
        {
          "input": " height = [1,8,6,2,5,4,8,3,7]",
          "output": " 49",
          "explanation": " The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
        },
        {
          "input": " height = [1,1]",
          "output": " 1",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>n == height.length</code>",
        "<code>2 &lt;= n &lt;= 10<sup>5</sup></code>",
        "<code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code>"
      ],
      "description": "You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.<br /><br />Find two lines that together with the x-axis form a container, such that the container contains the most water.<br /><br />Return <em>the maximum amount of water a container can store</em>.<br /><br /><strong>Notice</strong> that you may not slant the container.<br /><br />&nbsp;<br /><br />"
    },
    "sum-of-two-integers": {
      "title": "Sum of Two Integers",
      "difficulty": "Medium",
      "topics": ["Math", "Bit Manipulation"],
      "examples": [
        {
          "input": " a = 1, b = 2",
          "output": " 3",
          "explanation": null
        },
        {
          "input": " a = 2, b = 3",
          "output": " 5",
          "explanation": null
        }
      ],
      "constraints": ["<code>-1000 &lt;= a, b &lt;= 1000</code>"],
      "description": "Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.<br /><br />&nbsp;<br /><br />"
    },
    "number-of-1-bits": {
      "title": "Number of 1 Bits",
      "difficulty": "Easy",
      "topics": ["Divide and Conquer", "Bit Manipulation"],
      "examples": [],
      "constraints": ["<code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code>"],
      "description": "Given a positive integer <code>n</code>, write a function that returns the number of <span data-keyword=\"set-bit\" class=\" cursor-pointer relative text-dark-blue-s text-sm\"><div class=\"popover-wrapper inline-block\" data-headlessui-state=\"\"><div><div aria-expanded=\"false\" data-headlessui-state=\"\" id=\"headlessui-popover-button-:r2c:\"><div>set bits</div></div><div style=\"position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(485px, 182px);\"></div></div></div></span> in its binary representation (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">Hamming weight</a>).<br /><br />&nbsp;<br /><br />"
    },
    "counting-bits": {
      "title": "Counting Bits",
      "difficulty": "Easy",
      "topics": ["Dynamic Programming", "Bit Manipulation"],
      "examples": [
        {
          "input": " n = 2",
          "output": " [0,1,1]",
          "explanation": "0 --> 0\n1 --> 1\n2 --> 10\n"
        },
        {
          "input": " n = 5",
          "output": " [0,1,1,2,1,2]",
          "explanation": "0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n"
        }
      ],
      "constraints": ["<code>0 &lt;= n &lt;= 10<sup>5</sup></code>"],
      "description": "Given an integer <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n + 1</code><em> such that for each </em><code>i</code><em> </em>(<code>0 &lt;= i &lt;= n</code>)<em>, </em><code>ans[i]</code><em> is the <strong>number of </strong></em><code>1</code><em><strong>'s</strong> in the binary representation of </em><code>i</code>.<br /><br />&nbsp;<br /><br />"
    },
    "missing-number": {
      "title": "Missing Number",
      "difficulty": "Easy",
      "topics": [
        "Array",
        "Hash Table",
        "Math",
        "Binary Search",
        "Bit Manipulation",
        "Sorting"
      ],
      "examples": [
        {
          "input": " nums = [3,0,1]",
          "output": " 2",
          "explanation": " n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums."
        },
        {
          "input": " nums = [0,1]",
          "output": " 2",
          "explanation": " n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
        },
        {
          "input": " nums = [9,6,4,2,3,5,7,0,1]",
          "output": " 8",
          "explanation": " n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums."
        }
      ],
      "constraints": [
        "<code>n == nums.length</code>",
        "<code>1 &lt;= n &lt;= 10<sup>4</sup></code>",
        "<code>0 &lt;= nums[i] &lt;= n</code>",
        "All the numbers of <code>nums</code> are <strong>unique</strong>."
      ],
      "description": "Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em><br /><br />&nbsp;<br /><br />"
    },
    "reverse-bits": {
      "title": "Reverse Bits",
      "difficulty": "Easy",
      "topics": ["Divide and Conquer", "Bit Manipulation"],
      "examples": [
        {
          "input": " n = 00000010100101000001111010011100",
          "output": "    964176192 (00111001011110000010100101000000)",
          "explanation": null
        },
        {
          "input": " n = 11111111111111111111111111111101",
          "output": "   3221225471 (10111111111111111111111111111111)",
          "explanation": null
        }
      ],
      "constraints": [
        "Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.",
        "In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2's complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>."
      ],
      "description": "Reverse bits of a given 32 bits unsigned integer.<br /><br /><strong>Note:</strong><br /><br />\n\t<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2's complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n<br /><br />&nbsp;<br /><br />"
    },
    "climbing-stairs": {
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "topics": ["Math", "Dynamic Programming", "Memoization"],
      "examples": [
        {
          "input": " n = 2",
          "output": " 2",
          "explanation": " There are two ways to climb to the top.1. 1 step + 1 step\n2. 2 steps\n"
        },
        {
          "input": " n = 3",
          "output": " 3",
          "explanation": " There are three ways to climb to the top.1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n"
        }
      ],
      "constraints": ["<code>1 &lt;= n &lt;= 45</code>"],
      "description": "You are climbing a staircase. It takes <code>n</code> steps to reach the top.<br /><br />Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?<br /><br />&nbsp;<br /><br />"
    },
    "coin-change": {
      "title": "Coin Change",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming", "Breadth-First Search"],
      "examples": [
        {
          "input": " coins = [1,2,5], amount = 11",
          "output": " 3",
          "explanation": " 11 = 5 + 5 + 1"
        },
        {
          "input": " coins = [2], amount = 3",
          "output": " -1",
          "explanation": null
        },
        {
          "input": " coins = [1], amount = 0",
          "output": " 0",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= coins.length &lt;= 12</code>",
        "<code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code>",
        "<code>0 &lt;= amount &lt;= 10<sup>4</sup></code>"
      ],
      "description": "You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br /><br />Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.<br /><br />You may assume that you have an infinite number of each kind of coin.<br /><br />&nbsp;<br /><br />"
    },
    "longest-increasing-subsequence": {
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "topics": ["Array", "Binary Search", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [10,9,2,5,3,7,101,18]",
          "output": " 4",
          "explanation": " The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
        },
        {
          "input": " nums = [0,1,0,3,2,3]",
          "output": " 4",
          "explanation": null
        },
        {
          "input": " nums = [7,7,7,7,7,7,7]",
          "output": " 1",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 2500</code>",
        "<code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>"
      ],
      "description": "Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=\"subsequence-array\" class=\" cursor-pointer relative text-dark-blue-s text-sm\"><div class=\"popover-wrapper inline-block\" data-headlessui-state=\"\"><div><div aria-expanded=\"false\" data-headlessui-state=\"\" id=\"headlessui-popover-button-:r2c:\"><div><em><strong>subsequence</strong></em></div></div><div style=\"position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(560px, 182px);\"></div></div></div></span>.<br /><br />&nbsp;<br /><br />"
    },
    "word-break": {
      "title": "Word Break",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "Hash Table",
        "String",
        "Dynamic Programming",
        "Trie",
        "Memoization"
      ],
      "examples": [
        {
          "input": " s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "output": " true",
          "explanation": " Return true because \"leetcode\" can be segmented as \"leet code\"."
        },
        {
          "input": " s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "output": " true",
          "explanation": " Return true because \"applepenapple\" can be segmented as \"apple pen apple\".Note that you are allowed to reuse a dictionary word.\n"
        },
        {
          "input": " s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "output": " false",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= s.length &lt;= 300</code>",
        "<code>1 &lt;= wordDict.length &lt;= 1000</code>",
        "<code>1 &lt;= wordDict[i].length &lt;= 20</code>",
        "<code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.",
        "All the strings of <code>wordDict</code> are <strong>unique</strong>."
      ],
      "description": "Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.<br /><br /><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.<br /><br />&nbsp;<br /><br />"
    },
    "combination-sum-iv": {
      "title": "Combination Sum IV",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [1,2,3], target = 4",
          "output": " 7",
          "explanation": "The possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n"
        },
        {
          "input": " nums = [9], target = 3",
          "output": " 0",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 200</code>",
        "<code>1 &lt;= nums[i] &lt;= 1000</code>",
        "All the elements of <code>nums</code> are <strong>unique</strong>.",
        "<code>1 &lt;= target &lt;= 1000</code>"
      ],
      "description": "Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em>&nbsp;<code>target</code>.<br /><br />The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.<br /><br />&nbsp;<br /><br />"
    },
    "house-robber": {
      "title": "House Robber",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [1,2,3,1]",
          "output": " 4",
          "explanation": " Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.\n"
        },
        {
          "input": " nums = [2,7,9,3,1]",
          "output": " 12",
          "explanation": " Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12.\n"
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 100</code>",
        "<code>0 &lt;= nums[i] &lt;= 400</code>"
      ],
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.<br /><br />Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.<br /><br />&nbsp;<br /><br />"
    },
    "house-robber-ii": {
      "title": "House Robber II",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming"],
      "examples": [
        {
          "input": " nums = [2,3,2]",
          "output": " 3",
          "explanation": " You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
        },
        {
          "input": " nums = [1,2,3,1]",
          "output": " 4",
          "explanation": " Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.\n"
        },
        {
          "input": " nums = [1,2,3]",
          "output": " 3",
          "explanation": null
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 100</code>",
        "<code>0 &lt;= nums[i] &lt;= 1000</code>"
      ],
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.<br /><br />Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.<br /><br />&nbsp;<br /><br />"
    },
    "decode-ways": {
      "title": "Decode Ways",
      "difficulty": "Medium",
      "topics": ["String", "Dynamic Programming"],
      "examples": [],
      "constraints": [
        "<code>\"AAJF\"</code> with the grouping <code>(1, 1, 10, 6)</code>",
        "<code>\"KJF\"</code> with the grouping <code>(11, 10, 6)</code>",
        "The grouping <code>(1, 11, 06)</code> is invalid because <code>\"06\"</code> is not a valid code (only <code>\"6\"</code> is valid)."
      ],
      "description": "You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:<br /><br /><code>\"1\" -&gt; 'A'<br>\n\"2\" -&gt; 'B'<br>\n...<br>\n\"25\" -&gt; 'Y'<br>\n\"26\" -&gt; 'Z'</code><br /><br />However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code>\"2\"</code> and <code>\"5\"</code> vs <code>\"25\"</code>).<br /><br />For example, <code>\"11106\"</code> can be decoded into:<br /><br />\n\t<li><code>\"AAJF\"</code> with the grouping <code>(1, 1, 10, 6)</code></li>\n\t<li><code>\"KJF\"</code> with the grouping <code>(11, 10, 6)</code></li>\n\t<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>\"06\"</code> is not a valid code (only <code>\"6\"</code> is valid).</li>\n<br /><br />Note: there may be strings that are impossible to decode.<br>\n<br>\nGiven a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.<br /><br />The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.<br /><br />&nbsp;<br /><br />"
    },
    "unique-paths": {
      "title": "Unique Paths",
      "difficulty": "Medium",
      "topics": ["Math", "Dynamic Programming", "Combinatorics"],
      "examples": [
        {
          "input": " m = 3, n = 7",
          "output": " 28",
          "explanation": null
        },
        {
          "input": " m = 3, n = 2",
          "output": " 3",
          "explanation": " From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n"
        }
      ],
      "constraints": ["<code>1 &lt;= m, n &lt;= 100</code>"],
      "description": "There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.<br /><br />Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.<br /><br />The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.<br /><br />&nbsp;<br /><br />"
    },
    "jump-game": {
      "title": "Jump Game",
      "difficulty": "Medium",
      "topics": ["Array", "Dynamic Programming", "Greedy"],
      "examples": [
        {
          "input": " nums = [2,3,1,1,4]",
          "output": " true",
          "explanation": " Jump 1 step from index 0 to 1, then 3 steps to the last index."
        },
        {
          "input": " nums = [3,2,1,0,4]",
          "output": " false",
          "explanation": " You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
        }
      ],
      "constraints": [
        "<code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code>",
        "<code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code>"
      ],
      "description": "You are given an integer array <code>nums</code>. You are initially positioned at the array's <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.<br /><br />Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.<br /><br />&nbsp;<br /><br />"
    },
    "clone-graph": {
      "title": "Clone Graph",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "constraints": [
        "The number of nodes in the graph is in the range <code>[0, 100]</code>.",
        "<code>1 &lt;= Node.val &lt;= 100</code>",
        "<code>Node.val</code> is unique for each node.",
        "There are no repeated edges and no self-loops in the graph.",
        "The Graph is connected and all nodes can be visited starting from the given node."
      ],
      "description": "Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.<br /><br />Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.<br /><br />Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.<br /><br />class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n<br /><br />&nbsp;<br /><br /><strong>Test case format:</strong><br /><br />For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.<br /><br /><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.<br /><br />The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.<br /><br />&nbsp;<br /><br />"
    },
    "course-schedule": {
      "title": "Course Schedule",
      "difficulty": "Medium",
      "topics": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "examples": [
        {
          "input": " numCourses = 2, prerequisites = [[1,0]]",
          "output": " true",
          "explanation": " There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n"
        },
        {
          "input": " numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "output": " false",
          "explanation": " There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n"
        }
      ],
      "constraints": [
        "For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>."
      ],
      "description": "There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.<br /><br />\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n<br /><br />Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.<br /><br />&nbsp;<br /><br />"
    },
    "pacific-atlantic-water-flow": {
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Medium",
      "topics": ["Array", "Depth-First Search", "Breadth-First Search", "Matrix"],
      "examples": [
        {
          "input": " heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
          "output": " [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
          "explanation": " The following cells can flow to the Pacific and Atlantic oceans, as shown below:[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n"
        },
        {
          "input": " heights = [[1]]",
          "output": " [[0,0]]",
          "explanation": " The water can flow from the only cell to the Pacific and Atlantic oceans."
        }
      ],
      "constraints": [
        "<code>m == heights.length</code>",
        "<code>n == heights[r].length</code>",
        "<code>1 &lt;= m, n &lt;= 200</code>",
        "<code>0 &lt;= heights[r][c] &lt;= 10<sup>5</sup></code>"
      ],
      "description": "There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island's left and top edges, and the <strong>Atlantic Ocean</strong> touches the island's right and bottom edges.<br /><br />The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.<br /><br />The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is <strong>less than or equal to</strong> the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.<br /><br />Return <em>a <strong>2D list</strong> of grid coordinates </em><code>result</code><em> where </em><code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code><em> denotes that rain water can flow from cell </em><code>(r<sub>i</sub>, c<sub>i</sub>)</code><em> to <strong>both</strong> the Pacific and Atlantic oceans</em>.<br /><br />&nbsp;<br /><br />"
    }
  }