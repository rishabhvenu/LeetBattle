name: Deploy Frontend to AWS (CDK)

on:
  workflow_run:
    workflows: ["Build Frontend (OpenNext)"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      artifact_name:
        description: 'OpenNext artifact name (from build workflow)'
        required: false
        default: ''

# Ensure only one deployment runs at a time
concurrency:
  group: frontend-deployment
  cancel-in-progress: false

# Permissions for OIDC authentication and artifact access
permissions:
  id-token: write
  contents: read
  actions: read  # Required to download artifacts from other workflow runs

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only deploy if build workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js (for client build)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: client/package-lock.json

      - name: Setup Node.js (for CDK)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: client/infra/package-lock.json

      - name: Debug artifact info
        if: ${{ github.event_name == 'workflow_run' }}
        run: |
          echo "Workflow Run ID: ${{ github.event.workflow_run.id }}"
          echo "Head SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "Current SHA: ${{ github.sha }}"
          echo "Expected artifact name: open-next-artifacts-${{ github.event.workflow_run.head_sha }}"
          
      - name: List downloaded artifacts
        if: always()
        run: |
          echo "=== Current directory structure ==="
          pwd
          ls -la || true
          echo ""
          echo "=== client/ directory ==="
          ls -la client/ || true
          echo ""
          if [ -d "client/.open-next" ]; then
            echo "=== client/.open-next exists ==="
            du -sh client/.open-next || true
          fi

      - name: Download OpenNext build artifacts (from workflow_run)
        if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' }}
        uses: actions/download-artifact@v4
        with:
          pattern: open-next-artifacts-*
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
          path: .open-next-temp
          merge-multiple: false
          
      - name: Move artifacts to correct location
        if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' }}
        run: |
          echo "=== Checking temp download location ==="
          if [ -d ".open-next-temp" ]; then
            ls -la .open-next-temp/ || true
            echo ""
            
            # Find the actual .open-next directory - could be nested in artifact-named directory
            if [ -d ".open-next-temp/.open-next" ]; then
              echo "Found nested .open-next structure, moving contents"
              rm -rf client/.open-next || true
              mv .open-next-temp/.open-next client/.open-next
            elif [ -d ".open-next-temp/client/.open-next" ]; then
              echo "Found nested client/.open-next structure, moving contents"
              rm -rf client/.open-next || true
              mv .open-next-temp/client/.open-next client/.open-next
            else
              # Check if there's an artifact-named directory containing the .open-next structure
              ARTIFACT_DIR=$(find .open-next-temp -maxdepth 1 -type d -name "open-next-artifacts-*" | head -1)
              if [ -n "$ARTIFACT_DIR" ] && [ -d "$ARTIFACT_DIR" ]; then
                echo "Found artifact directory: $ARTIFACT_DIR"
                echo "Contents:"
                ls -la "$ARTIFACT_DIR/" | head -10 || true
                # The artifact directory IS the .open-next content (server-functions, etc. are directly inside)
                rm -rf client/.open-next || true
                mv "$ARTIFACT_DIR" client/.open-next
              else
                echo "Artifact is at root level, moving to client/"
                rm -rf client/.open-next || true
                mkdir -p client
                mv .open-next-temp client/.open-next
              fi
            fi
            rm -rf .open-next-temp
          fi

      - name: Download artifact (manual dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: .open-next-temp
          
      - name: Move artifacts to correct location (manual)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.artifact_name != '' }}
        run: |
          if [ -d ".open-next-temp" ]; then
            if [ -d ".open-next-temp/.open-next" ]; then
              rm -rf client/.open-next || true
              mv .open-next-temp/.open-next client/.open-next
            elif [ -d ".open-next-temp/client/.open-next" ]; then
              rm -rf client/.open-next || true
              mv .open-next-temp/client/.open-next client/.open-next
            else
              # Check for artifact-named directory
              ARTIFACT_DIR=$(find .open-next-temp -maxdepth 1 -type d -name "open-next-artifacts-*" | head -1)
              if [ -n "$ARTIFACT_DIR" ] && [ -d "$ARTIFACT_DIR" ]; then
                echo "Found artifact directory: $ARTIFACT_DIR"
                rm -rf client/.open-next || true
                mv "$ARTIFACT_DIR" client/.open-next
              else
                rm -rf client/.open-next || true
                mkdir -p client
                mv .open-next-temp client/.open-next
              fi
            fi
            rm -rf .open-next-temp
          fi

      - name: 'Guard: Verify .open-next directory structure'
        id: verify-artifacts
        run: |
          if [ ! -d "client/.open-next" ]; then
            echo "âŒ .open-next directory not found"
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 0  # Don't fail yet - we'll build it
          fi
          echo "=== .open-next directory structure ==="
          ls -la client/.open-next/ || true
          echo ""
          echo "=== Checking for server function paths ==="
          if [ -d "client/.open-next/server-functions/default" ]; then
            echo "âœ… Found: client/.open-next/server-functions/default"
            ls -la client/.open-next/server-functions/default/ | head -10 || true
            echo "exists=true" >> $GITHUB_OUTPUT
          elif [ -d "client/.open-next/server-function" ]; then
            echo "âœ… Found: client/.open-next/server-function"
            ls -la client/.open-next/server-function/ | head -10 || true
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Invalid structure: Neither server-functions/default nor server-function found"
            echo "Available directories:"
            find client/.open-next -maxdepth 2 -type d | head -20
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          echo ""
          if [ "$(cat $GITHUB_OUTPUT | grep '^exists=' | cut -d'=' -f2)" = "true" ]; then
            echo "âœ… Verified .open-next artifacts structure"
          fi

      - name: Clean old OpenNext build
        if: steps.verify-artifacts.outputs.exists != 'true'
        run: rm -rf client/.open-next

      - name: Build OpenNext
        if: steps.verify-artifacts.outputs.exists != 'true'
        working-directory: ./client
        env:
          NODE_ENV: production
          NEXTAUTH_URL: ${{ vars.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          # Note: CACHE_BUCKET_NAME is set at runtime via Lambda environment variables
          # The bucket is created by CDK during deployment, so we don't know its name at build time
          CACHE_BUCKET_REGION: us-east-1
        run: |
          npm ci
          npx open-next build

      - name: Install CDK dependencies
        working-directory: ./client/infra
        run: npm ci

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-FrontendDeploy
          aws-region: us-east-1

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "Error: AWS_ROLE_ARN secret is required for OIDC authentication"
            exit 1
          fi
          if [ -z "${{ secrets.AWS_ACCOUNT_ID }}" ]; then
            echo "Error: AWS_ACCOUNT_ID secret is required"
            exit 1
          fi

      - name: Bootstrap CDK
        working-directory: ./client/infra
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: npx cdk bootstrap aws://$AWS_ACCOUNT_ID/us-east-1 || echo "Bootstrap already done"

      - name: Fetch hosted zone name (if ID provided)
        id: hosted-zone
        run: |
          ROUTE53_HOSTED_ZONE_ID="${{ secrets.ROUTE53_HOSTED_ZONE_ID }}"
          ROUTE53_HOSTED_ZONE_NAME="${{ vars.ROUTE53_HOSTED_ZONE_NAME }}"
          
          if [ -z "$ROUTE53_HOSTED_ZONE_NAME" ] && [ -n "$ROUTE53_HOSTED_ZONE_ID" ]; then
            echo "Fetching hosted zone name from ID..."
            ZONE_NAME=$(aws route53 get-hosted-zone --id "$ROUTE53_HOSTED_ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//' || echo "")
            if [ -n "$ZONE_NAME" ]; then
              echo "name=$ZONE_NAME" >> $GITHUB_OUTPUT
              echo "âœ… Found hosted zone name: $ZONE_NAME"
            else
              echo "âš ï¸  Could not fetch hosted zone name, will use default 'leetbattle.net'"
              echo "name=leetbattle.net" >> $GITHUB_OUTPUT
            fi
          elif [ -n "$ROUTE53_HOSTED_ZONE_NAME" ]; then
            echo "name=$ROUTE53_HOSTED_ZONE_NAME" >> $GITHUB_OUTPUT
            echo "âœ… Using provided hosted zone name: $ROUTE53_HOSTED_ZONE_NAME"
          else
            echo "name=leetbattle.net" >> $GITHUB_OUTPUT
            echo "âš ï¸  No hosted zone name or ID provided, using default 'leetbattle.net'"
          fi

      - name: Debug domain configuration
        run: |
          echo "=== Domain Configuration Debug ==="
          ROUTE53_HOSTED_ZONE_NAME="${{ steps.hosted-zone.outputs.name || vars.ROUTE53_HOSTED_ZONE_NAME || 'leetbattle.net' }}"
          NEXTJS_DOMAIN_NAME="${{ vars.NEXTJS_DOMAIN_NAME }}"
          echo "ROUTE53_HOSTED_ZONE_ID: ${{ secrets.ROUTE53_HOSTED_ZONE_ID }}"
          echo "ROUTE53_HOSTED_ZONE_NAME: $ROUTE53_HOSTED_ZONE_NAME"
          echo "NEXTJS_DOMAIN_NAME: ${NEXTJS_DOMAIN_NAME:-'(not set)'}"
          echo ""
          if [ -z "${{ secrets.ROUTE53_HOSTED_ZONE_ID }}" ]; then
            echo "â„¹ï¸  No ROUTE53_HOSTED_ZONE_ID set - CloudFront will deploy WITHOUT custom domains"
            echo "   CloudFront will use the default distribution domain (*.cloudfront.net)"
          elif [ -z "$NEXTJS_DOMAIN_NAME" ]; then
            echo "â„¹ï¸  No NEXTJS_DOMAIN_NAME set - CloudFront will deploy WITHOUT custom domains"
            echo "   CloudFront will use the default distribution domain (*.cloudfront.net)"
            echo "   To enable custom domains, set NEXTJS_DOMAIN_NAME (e.g., 'www' or 'app')"
          else
            echo "Expected CloudFront CNAMEs will be:"
            DOMAIN="$NEXTJS_DOMAIN_NAME"
            HOSTED_ZONE="$ROUTE53_HOSTED_ZONE_NAME"
            # Logic matches infrastructure-stack.ts
            if [[ "$DOMAIN" == *".$HOSTED_ZONE" ]]; then
              ROOT_DOMAIN="${DOMAIN%.$HOSTED_ZONE}"
              ROOT_DOMAIN_FULL="$DOMAIN"
            elif [[ "$DOMAIN" == *"."* ]]; then
              ROOT_DOMAIN=$(echo "$DOMAIN" | rev | cut -d'.' -f1-2 | rev)
              ROOT_DOMAIN_FULL="$ROOT_DOMAIN"
            else
              ROOT_DOMAIN="$DOMAIN"
              ROOT_DOMAIN_FULL="$ROOT_DOMAIN.$HOSTED_ZONE"
            fi
            echo "  1. $ROOT_DOMAIN_FULL"
            if [ "$ROOT_DOMAIN_FULL" != "www.$HOSTED_ZONE" ]; then
              echo "  2. www.$HOSTED_ZONE"
            fi
            echo ""
            echo "âš ï¸  If deployment fails with 'CNAME already associated', check existing CloudFront distributions for these domains"
          fi

      - name: Force rebuild OpenNext (always fresh)
        run: |
          echo "ðŸ”„ Force rebuilding OpenNext to ensure latest config and code..."
          echo "âš ï¸  This rebuild runs unconditionally to prevent stale artifacts"
          rm -rf client/.open-next
          cd client
          npm ci
          npx open-next build
          cd ..
          echo "âœ… OpenNext build complete - ready for deployment"
        env:
          NODE_ENV: production
          NEXTAUTH_URL: ${{ vars.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          # Note: CACHE_BUCKET_NAME will be set at runtime by CDK via Lambda env vars
          # The bucket is auto-generated by CDK, so we don't know its name at build time
          CACHE_BUCKET_REGION: us-east-1

      - name: Deploy infrastructure with CDK
        working-directory: ./client/infra
        id: deploy
        env:
          CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
          CDK_DEFAULT_REGION: us-east-1
          AWS_REGION: us-east-1
          S3_BUCKET_NAME: ${{ vars.S3_BUCKET_NAME }}
          ROUTE53_HOSTED_ZONE_ID: ${{ secrets.ROUTE53_HOSTED_ZONE_ID }}
          ROUTE53_HOSTED_ZONE_NAME: ${{ steps.hosted-zone.outputs.name || vars.ROUTE53_HOSTED_ZONE_NAME || '' }}
          NEXTJS_DOMAIN_NAME: ${{ vars.NEXTJS_DOMAIN_NAME }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ vars.NEXTAUTH_URL }}
          REDIS_HOST: ${{ vars.REDIS_HOST }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          NEXT_PUBLIC_API_BASE: ${{ vars.NEXT_PUBLIC_API_BASE }}
          NEXT_PUBLIC_COLYSEUS_HTTP_URL: ${{ vars.NEXT_PUBLIC_COLYSEUS_HTTP_URL }}
          NEXT_PUBLIC_COLYSEUS_WS_URL: ${{ vars.NEXT_PUBLIC_COLYSEUS_WS_URL }}
          # NEXTJS_STATIC_BUCKET_NAME: Optional - only set if you want to reuse an existing bucket
          # If not set, CDK will create a new bucket with auto-generated name
          COLYSEUS_DOMAIN: ${{ vars.COLYSEUS_DOMAIN }}
          COLYSEUS_HOST_IP: ${{ vars.COLYSEUS_HOST_IP }}
        run: |
          npx cdk deploy --all --require-approval never --context account=${{ secrets.AWS_ACCOUNT_ID }} --context region=us-east-1

      - name: Get CloudFront URL
        working-directory: ./client/infra
        if: success()
        id: cloudfront-url
        run: |
          DISTRIBUTION_URL=$(aws cloudformation describe-stacks \
            --stack-name FrontendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`NextJsDistributionUrl`].OutputValue' \
            --output text \
            --region us-east-1)
          echo "url=$DISTRIBUTION_URL" >> $GITHUB_OUTPUT
          echo "CloudFront URL: $DISTRIBUTION_URL"

      - name: Post-deploy validation
        if: success()
        run: |
          URL="${{ steps.cloudfront-url.outputs.url }}"
          if [ -z "$URL" ]; then
            echo "Warning: Could not retrieve CloudFront URL for validation"
            exit 0
          fi
          echo "Validating deployment at $URL"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --fail --max-time 30 "$URL" || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "Deployment validation successful (HTTP $HTTP_CODE)"
          else
            echo "Warning: Deployment validation returned HTTP $HTTP_CODE (may still be propagating)"
          fi

      - name: Optional rollback on failure
        if: failure()
        run: |
          echo "Deployment failed - rollback option available"
          echo "To rollback manually, run: cd client/infra && npx cdk destroy --force"

      - name: Output deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "Infrastructure deployed successfully!"
            echo "CloudFront URL: ${{ steps.cloudfront-url.outputs.url }}"
            echo "Check CloudFormation console for full details"
          else
            echo "Deployment failed - check logs above"
          fi
