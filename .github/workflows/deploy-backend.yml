name: Deploy Backend to Oracle Cloud (Kubernetes)

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:

# Ensure only one deployment runs at a time
concurrency:
  group: backend-deployment
  cancel-in-progress: false

permissions:
  contents: read
  packages: write

jobs:
  changed-files:
    runs-on: ubuntu-latest
    outputs:
      colyseus: ${{ steps.filter.outputs.colyseus }}
      bots: ${{ steps.filter.outputs.bots }}
      judge0_api: ${{ steps.filter.outputs.judge0_api }}
      judge0_worker: ${{ steps.filter.outputs.judge0_worker }}
      judge0: ${{ steps.filter.outputs.judge0 }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need at least 2 commits to compare

      - name: Check for changed files
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            colyseus:
              - 'backend/colyseus/**'
            bots:
              - 'backend/bots/**'
            judge0_api:
              - 'backend/judge0/api/**'
            judge0_worker:
              - 'backend/judge0/worker/**'
            judge0:
              - 'backend/judge0/**'

  deploy:
    runs-on: self-hosted  # Runs on your Oracle VM runner
    needs: changed-files
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image tag
        id: meta
        run: |
          export IMAGE_TAG=$(git rev-parse --short HEAD)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Image tag: $IMAGE_TAG"

      - name: Build and push Colyseus image
        id: build-colyseus
        if: needs.changed-files.outputs.colyseus == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend/colyseus
          push: true
          tags: |
            ghcr.io/rishabhvenu/codeclashers-colyseus:${{ env.IMAGE_TAG }}
            ghcr.io/rishabhvenu/codeclashers-colyseus:latest
          cache-from: type=gha
          cache-to: type=gha

      - name: Build and push Bots image
        id: build-bots
        if: needs.changed-files.outputs.bots == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend/bots
          push: true
          tags: |
            ghcr.io/rishabhvenu/codeclashers-bots:${{ env.IMAGE_TAG }}
            ghcr.io/rishabhvenu/codeclashers-bots:latest
          cache-from: type=gha
          cache-to: type=gha

      - name: Build and push Judge0 API image
        id: build-judge0-api
        if: |
          needs.changed-files.outputs.judge0_api == 'true' ||
          needs.changed-files.outputs.judge0 == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend/judge0/api
          push: true
          platforms: linux/arm64
          tags: |
            ghcr.io/rishabhvenu/codeclashers-judge0-api-arm64:${{ env.IMAGE_TAG }}
            ghcr.io/rishabhvenu/codeclashers-judge0-api-arm64:latest
          cache-from: type=gha
          cache-to: type=gha

      - name: Build and push Judge0 Worker image
        id: build-judge0-worker
        if: |
          needs.changed-files.outputs.judge0_worker == 'true' ||
          needs.changed-files.outputs.judge0 == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend/judge0/worker
          push: true
          platforms: linux/arm64
          tags: |
            ghcr.io/rishabhvenu/codeclashers-judge0-worker-arm64:${{ env.IMAGE_TAG }}
            ghcr.io/rishabhvenu/codeclashers-judge0-worker-arm64:latest
          cache-from: type=gha
          cache-to: type=gha

      - name: Set image tags for deployment
        id: image-tags
        run: |
          # Use IMAGE_TAG if build ran, otherwise use 'latest'
          if [ "${{ steps.build-colyseus.outcome }}" != "skipped" ]; then
            echo "COLYSEUS_IMAGE=ghcr.io/rishabhvenu/codeclashers-colyseus:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
          else
            echo "COLYSEUS_IMAGE=ghcr.io/rishabhvenu/codeclashers-colyseus:latest" >> $GITHUB_ENV
          fi
          
          if [ "${{ steps.build-bots.outcome }}" != "skipped" ]; then
            echo "BOTS_IMAGE=ghcr.io/rishabhvenu/codeclashers-bots:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
          else
            echo "BOTS_IMAGE=ghcr.io/rishabhvenu/codeclashers-bots:latest" >> $GITHUB_ENV
          fi
          
          if [ "${{ steps.build-judge0-api.outcome }}" != "skipped" ]; then
            echo "JUDGE0_IMAGE=ghcr.io/rishabhvenu/codeclashers-judge0-api-arm64:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
          else
            echo "JUDGE0_IMAGE=ghcr.io/rishabhvenu/codeclashers-judge0-api-arm64:latest" >> $GITHUB_ENV
          fi
          
          if [ "${{ steps.build-judge0-worker.outcome }}" != "skipped" ]; then
            echo "JUDGE0_WORKER_IMAGE=ghcr.io/rishabhvenu/codeclashers-judge0-worker-arm64:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
          else
            echo "JUDGE0_WORKER_IMAGE=ghcr.io/rishabhvenu/codeclashers-judge0-worker-arm64:latest" >> $GITHUB_ENV
          fi

      - name: Ensure namespace exists
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          k3s kubectl create namespace codeclashers --dry-run=client -o yaml | k3s kubectl apply -f -

      - name: Deploy to Kubernetes
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          KUBECONFIG: /home/ubuntu/.kube/config
          # Image tags for envsubst (set by image-tags step above)
          COLYSEUS_IMAGE: ${{ env.COLYSEUS_IMAGE }}
          BOTS_IMAGE: ${{ env.BOTS_IMAGE }}
          JUDGE0_IMAGE: ${{ env.JUDGE0_IMAGE }}
          JUDGE0_WORKER_IMAGE: ${{ env.JUDGE0_WORKER_IMAGE }}
          # External IP for services
          ORACLE_VM_IP: ${{ vars.COLYSEUS_HOST_IP }}
          # Redis password for ConfigMap substitution
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          # Resource configuration (from secrets/vars, with defaults)
          K8S_MONGODB_REPLICAS: ${{ secrets.K8S_MONGODB_REPLICAS || '1' }}
          K8S_MONGODB_MEMORY_REQUEST: ${{ secrets.K8S_MONGODB_MEMORY_REQUEST || '512Mi' }}
          K8S_MONGODB_MEMORY_LIMIT: ${{ secrets.K8S_MONGODB_MEMORY_LIMIT || '1Gi' }}
          K8S_MONGODB_CPU_REQUEST: ${{ secrets.K8S_MONGODB_CPU_REQUEST || '50m' }}
          K8S_MONGODB_CPU_LIMIT: ${{ secrets.K8S_MONGODB_CPU_LIMIT || '200m' }}
          K8S_REDIS_REPLICAS: ${{ secrets.K8S_REDIS_REPLICAS || '1' }}
          K8S_REDIS_MEMORY_REQUEST: ${{ secrets.K8S_REDIS_MEMORY_REQUEST || '256Mi' }}
          K8S_REDIS_MEMORY_LIMIT: ${{ secrets.K8S_REDIS_MEMORY_LIMIT || '512Mi' }}
          K8S_REDIS_CPU_REQUEST: ${{ secrets.K8S_REDIS_CPU_REQUEST || '50m' }}
          K8S_REDIS_CPU_LIMIT: ${{ secrets.K8S_REDIS_CPU_LIMIT || '200m' }}
          K8S_POSTGRES_REPLICAS: ${{ secrets.K8S_POSTGRES_REPLICAS || '1' }}
          K8S_POSTGRES_MEMORY_REQUEST: ${{ secrets.K8S_POSTGRES_MEMORY_REQUEST || '128Mi' }}
          K8S_POSTGRES_MEMORY_LIMIT: ${{ secrets.K8S_POSTGRES_MEMORY_LIMIT || '256Mi' }}
          K8S_POSTGRES_CPU_REQUEST: ${{ secrets.K8S_POSTGRES_CPU_REQUEST || '50m' }}
          K8S_POSTGRES_CPU_LIMIT: ${{ secrets.K8S_POSTGRES_CPU_LIMIT || '200m' }}
          K8S_COLYSEUS_REPLICAS: ${{ secrets.K8S_COLYSEUS_REPLICAS || '1' }}
          K8S_COLYSEUS_MEMORY_REQUEST: ${{ secrets.K8S_COLYSEUS_MEMORY_REQUEST || '256Mi' }}
          K8S_COLYSEUS_MEMORY_LIMIT: ${{ secrets.K8S_COLYSEUS_MEMORY_LIMIT || '512Mi' }}
          K8S_COLYSEUS_CPU_REQUEST: ${{ secrets.K8S_COLYSEUS_CPU_REQUEST || '50m' }}
          K8S_COLYSEUS_CPU_LIMIT: ${{ secrets.K8S_COLYSEUS_CPU_LIMIT || '200m' }}
          K8S_JUDGE0_SERVER_REPLICAS: ${{ secrets.K8S_JUDGE0_SERVER_REPLICAS || '1' }}
          K8S_JUDGE0_SERVER_MEMORY_REQUEST: ${{ secrets.K8S_JUDGE0_SERVER_MEMORY_REQUEST || '256Mi' }}
          K8S_JUDGE0_SERVER_MEMORY_LIMIT: ${{ secrets.K8S_JUDGE0_SERVER_MEMORY_LIMIT || '512Mi' }}
          K8S_JUDGE0_SERVER_CPU_REQUEST: ${{ secrets.K8S_JUDGE0_SERVER_CPU_REQUEST || '50m' }}
          K8S_JUDGE0_SERVER_CPU_LIMIT: ${{ secrets.K8S_JUDGE0_SERVER_CPU_LIMIT || '200m' }}
          K8S_JUDGE0_WORKER_REPLICAS: ${{ secrets.K8S_JUDGE0_WORKER_REPLICAS || '1' }}
          K8S_JUDGE0_WORKER_MEMORY_REQUEST: ${{ secrets.K8S_JUDGE0_WORKER_MEMORY_REQUEST || '512Mi' }}
          K8S_JUDGE0_WORKER_MEMORY_LIMIT: ${{ secrets.K8S_JUDGE0_WORKER_MEMORY_LIMIT || '1Gi' }}
          K8S_JUDGE0_WORKER_CPU_REQUEST: ${{ secrets.K8S_JUDGE0_WORKER_CPU_REQUEST || '50m' }}
          K8S_JUDGE0_WORKER_CPU_LIMIT: ${{ secrets.K8S_JUDGE0_WORKER_CPU_LIMIT || '400m' }}
          K8S_BOTS_REPLICAS: ${{ secrets.K8S_BOTS_REPLICAS || '1' }}
          K8S_BOTS_MEMORY_REQUEST: ${{ secrets.K8S_BOTS_MEMORY_REQUEST || '128Mi' }}
          K8S_BOTS_MEMORY_LIMIT: ${{ secrets.K8S_BOTS_MEMORY_LIMIT || '256Mi' }}
          K8S_BOTS_CPU_REQUEST: ${{ secrets.K8S_BOTS_CPU_REQUEST || '50m' }}
          K8S_BOTS_CPU_LIMIT: ${{ secrets.K8S_BOTS_CPU_LIMIT || '200m' }}
        run: |
          set -e
          
          # Ensure envsubst is installed
          if ! command -v envsubst &> /dev/null; then
            echo "Installing gettext package for envsubst..."
            sudo apt-get update && sudo apt-get install -y gettext-base
          fi
          
          cd backend/k8s
          
          # Apply manifests explicitly by subdirectory, EXCLUDING secrets/
          # Namespace
          k3s kubectl apply -f namespaces/
          
          # ConfigMaps (with env substitution for redis-cluster-config)
          for file in configmaps/*.yaml; do
            if [ -f "$file" ]; then
              if [[ "$file" == *"redis-cluster-config"* ]]; then
                # Redis cluster config needs password substitution
                envsubst < "$file" | k3s kubectl apply -f -
              else
                k3s kubectl apply -f "$file"
              fi
            fi
          done
          
          # Storage
          k3s kubectl apply -f storage/
          
          # MongoDB (if exists in separate directory)
          if [ -f mongodb/configmap.yaml ]; then
            k3s kubectl apply -f mongodb/configmap.yaml
          fi
          if [ -f mongodb/headless-service.yaml ]; then
            k3s kubectl apply -f mongodb/headless-service.yaml
          fi
          if [ -f mongodb/statefulset.yaml ]; then
            envsubst < mongodb/statefulset.yaml | k3s kubectl apply -f -
          fi
          if [ -f mongodb/pdb.yaml ]; then
            k3s kubectl apply -f mongodb/pdb.yaml
          fi
          
          # StatefulSets (with env substitution)
          for file in statefulsets/*.yaml; do
            if [ -f "$file" ]; then
              envsubst < "$file" | k3s kubectl apply -f -
            fi
          done
          
          # PodDisruptionBudgets
          k3s kubectl apply -f pdbs/
          
          # Services (with env substitution for externalIPs)
          for file in services/*.yaml; do
            if [ -f "$file" ]; then
              envsubst < "$file" | k3s kubectl apply -f -
            fi
          done
          
          # MongoDB service (if exists in separate directory)
          if [ -f mongodb/service.yaml ]; then
            envsubst < mongodb/service.yaml | k3s kubectl apply -f -
          fi
          
          # Deployments (with env substitution for image tags)
          for file in deployments/*.yaml; do
            if [ -f "$file" ]; then
              envsubst < "$file" | k3s kubectl apply -f -
            fi
          done
          
          echo "âœ… All manifests applied successfully"
          echo "Note: Secrets are managed separately via sync-secrets.yml workflow"
