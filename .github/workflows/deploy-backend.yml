name: Deploy Backend to Oracle Cloud (Kubernetes)

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:

# Ensure only one deployment runs at a time
concurrency:
  group: backend-deployment
  cancel-in-progress: false

permissions:
  contents: read
  packages: write

jobs:
  deploy:
    runs-on: self-hosted  # Runs on your Oracle VM runner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image tag
        id: meta
        run: |
          export IMAGE_TAG=$(git rev-parse --short HEAD)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Image tag: $IMAGE_TAG"

      - name: Build and push Colyseus image
        uses: docker/build-push-action@v5
        with:
          context: ./backend/colyseus
          push: true
          tags: ghcr.io/rishabhvenu/codeclashers-colyseus:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Bots image
        uses: docker/build-push-action@v5
        with:
          context: ./backend/bots
          push: true
          tags: ghcr.io/rishabhvenu/codeclashers-bots:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Stop docker-compose services (if running)
        run: |
          # Stop docker-compose services to avoid port conflicts
          # This is safe - K8s will handle traffic
          if [ -f "/opt/CodeClashers/backend/docker-compose.prod.yml" ]; then
            echo "Stopping docker-compose services..."
            cd /opt/CodeClashers/backend
            docker-compose -f docker-compose.prod.yml down || true
            echo "Docker compose services stopped"
          else
            echo "No docker-compose.prod.yml found, skipping"
          fi

      - name: Install k3s if not present
        run: |
          if ! command -v k3s &> /dev/null; then
            echo "Installing k3s..."
            chmod +x backend/k8s/install-k3s.sh
            bash backend/k8s/install-k3s.sh
          else
            echo "k3s already installed"
            k3s --version
            
            # Fix permissions if kubeconfig is not readable
            if [ ! -r ~/.kube/config ]; then
              echo "Fixing kubeconfig permissions..."
              sudo mkdir -p ~/.kube
              sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
              sudo chown -R $USER:$USER ~/.kube
            fi
          fi
          
          # Ensure envsubst is installed (comes with gettext package)
          if ! command -v envsubst &> /dev/null; then
            echo "Installing gettext package for envsubst..."
            sudo apt-get update && sudo apt-get install -y gettext-base
          fi

      - name: Create namespace if not exists
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          k3s kubectl create namespace codeclashers --dry-run=client -o yaml | k3s kubectl apply -f -

      - name: Create or update secrets
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          k3s kubectl create secret generic app-secrets \
            --namespace=codeclashers \
            --from-literal=REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}" \
            --from-literal=JUDGE0_POSTGRES_USER="${{ secrets.JUDGE0_POSTGRES_USER }}" \
            --from-literal=JUDGE0_POSTGRES_PASSWORD="${{ secrets.JUDGE0_POSTGRES_PASSWORD }}" \
            --from-literal=JUDGE0_POSTGRES_DB="${{ secrets.JUDGE0_POSTGRES_DB }}" \
            --from-literal=MONGODB_USERNAME="${{ secrets.MONGODB_USERNAME }}" \
            --from-literal=MONGODB_PASSWORD="${{ secrets.MONGODB_PASSWORD }}" \
            --from-literal=MONGODB_URI_INTERNAL="mongodb://${{ secrets.MONGODB_USERNAME }}:${{ secrets.MONGODB_PASSWORD }}@mongodb:27017/codeclashers?authSource=admin" \
            --from-literal=MONGODB_URI="${{ secrets.MONGODB_URI }}" \
            --from-literal=OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            --from-literal=INTERNAL_SERVICE_SECRET="${{ secrets.INTERNAL_SERVICE_SECRET }}" \
            --from-literal=BOT_SERVICE_SECRET="${{ secrets.BOT_SERVICE_SECRET }}" \
            --from-literal=COLYSEUS_RESERVATION_SECRET="${{ secrets.COLYSEUS_RESERVATION_SECRET }}" \
            --from-literal=AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            --from-literal=AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            --from-literal=S3_BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}" \
            --from-literal=AWS_REGION="${{ secrets.AWS_REGION }}" \
            --dry-run=client -o yaml | k3s kubectl apply -f -

      - name: Deploy to Kubernetes
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          KUBECONFIG: /home/ubuntu/.kube/config
          # MongoDB resources
          K8S_MONGODB_REPLICAS: ${{ secrets.K8S_MONGODB_REPLICAS || '1' }}
          K8S_MONGODB_MEMORY_REQUEST: ${{ secrets.K8S_MONGODB_MEMORY_REQUEST || '2Gi' }}
          K8S_MONGODB_MEMORY_LIMIT: ${{ secrets.K8S_MONGODB_MEMORY_LIMIT || '4Gi' }}
          K8S_MONGODB_CPU_REQUEST: ${{ secrets.K8S_MONGODB_CPU_REQUEST || '500m' }}
          K8S_MONGODB_CPU_LIMIT: ${{ secrets.K8S_MONGODB_CPU_LIMIT || '1000m' }}
          # Redis resources
          K8S_REDIS_REPLICAS: ${{ secrets.K8S_REDIS_REPLICAS || '1' }}
          K8S_REDIS_MEMORY_REQUEST: ${{ secrets.K8S_REDIS_MEMORY_REQUEST || '512Mi' }}
          K8S_REDIS_MEMORY_LIMIT: ${{ secrets.K8S_REDIS_MEMORY_LIMIT || '1Gi' }}
          K8S_REDIS_CPU_REQUEST: ${{ secrets.K8S_REDIS_CPU_REQUEST || '250m' }}
          K8S_REDIS_CPU_LIMIT: ${{ secrets.K8S_REDIS_CPU_LIMIT || '500m' }}
          # PostgreSQL resources
          K8S_POSTGRES_REPLICAS: ${{ secrets.K8S_POSTGRES_REPLICAS || '1' }}
          K8S_POSTGRES_MEMORY_REQUEST: ${{ secrets.K8S_POSTGRES_MEMORY_REQUEST || '256Mi' }}
          K8S_POSTGRES_MEMORY_LIMIT: ${{ secrets.K8S_POSTGRES_MEMORY_LIMIT || '512Mi' }}
          K8S_POSTGRES_CPU_REQUEST: ${{ secrets.K8S_POSTGRES_CPU_REQUEST || '250m' }}
          K8S_POSTGRES_CPU_LIMIT: ${{ secrets.K8S_POSTGRES_CPU_LIMIT || '500m' }}
          # Colyseus resources
          K8S_COLYSEUS_REPLICAS: ${{ secrets.K8S_COLYSEUS_REPLICAS || '2' }}
          K8S_COLYSEUS_MEMORY_REQUEST: ${{ secrets.K8S_COLYSEUS_MEMORY_REQUEST || '512Mi' }}
          K8S_COLYSEUS_MEMORY_LIMIT: ${{ secrets.K8S_COLYSEUS_MEMORY_LIMIT || '1Gi' }}
          K8S_COLYSEUS_CPU_REQUEST: ${{ secrets.K8S_COLYSEUS_CPU_REQUEST || '500m' }}
          K8S_COLYSEUS_CPU_LIMIT: ${{ secrets.K8S_COLYSEUS_CPU_LIMIT || '1000m' }}
          # Judge0 Server resources
          K8S_JUDGE0_SERVER_REPLICAS: ${{ secrets.K8S_JUDGE0_SERVER_REPLICAS || '2' }}
          K8S_JUDGE0_SERVER_MEMORY_REQUEST: ${{ secrets.K8S_JUDGE0_SERVER_MEMORY_REQUEST || '512Mi' }}
          K8S_JUDGE0_SERVER_MEMORY_LIMIT: ${{ secrets.K8S_JUDGE0_SERVER_MEMORY_LIMIT || '1Gi' }}
          K8S_JUDGE0_SERVER_CPU_REQUEST: ${{ secrets.K8S_JUDGE0_SERVER_CPU_REQUEST || '500m' }}
          K8S_JUDGE0_SERVER_CPU_LIMIT: ${{ secrets.K8S_JUDGE0_SERVER_CPU_LIMIT || '1000m' }}
          # Judge0 Worker resources
          K8S_JUDGE0_WORKER_REPLICAS: ${{ secrets.K8S_JUDGE0_WORKER_REPLICAS || '2' }}
          K8S_JUDGE0_WORKER_MEMORY_REQUEST: ${{ secrets.K8S_JUDGE0_WORKER_MEMORY_REQUEST || '1Gi' }}
          K8S_JUDGE0_WORKER_MEMORY_LIMIT: ${{ secrets.K8S_JUDGE0_WORKER_MEMORY_LIMIT || '2Gi' }}
          K8S_JUDGE0_WORKER_CPU_REQUEST: ${{ secrets.K8S_JUDGE0_WORKER_CPU_REQUEST || '1000m' }}
          K8S_JUDGE0_WORKER_CPU_LIMIT: ${{ secrets.K8S_JUDGE0_WORKER_CPU_LIMIT || '2000m' }}
          # Bots resources
          K8S_BOTS_REPLICAS: ${{ secrets.K8S_BOTS_REPLICAS || '2' }}
          K8S_BOTS_MEMORY_REQUEST: ${{ secrets.K8S_BOTS_MEMORY_REQUEST || '256Mi' }}
          K8S_BOTS_MEMORY_LIMIT: ${{ secrets.K8S_BOTS_MEMORY_LIMIT || '512Mi' }}
          K8S_BOTS_CPU_REQUEST: ${{ secrets.K8S_BOTS_CPU_REQUEST || '250m' }}
          K8S_BOTS_CPU_LIMIT: ${{ secrets.K8S_BOTS_CPU_LIMIT || '500m' }}
        run: |
          set -e
          
          # Apply manifests in order with environment substitution
          cd backend/k8s
          
          # Apply namespace
          k3s kubectl apply -f namespaces/
          
          # Apply ConfigMap
          k3s kubectl apply -f configmaps/
          
          # Apply storage
          k3s kubectl apply -f storage/
          
          # Wait for PVCs to be ready
          k3s kubectl wait --for=condition=bound pvc -n codeclashers --timeout=60s || true
          
          # Apply services
          k3s kubectl apply -f services/
          
          # Apply statefulsets with env substitution
          for file in statefulsets/*.yaml; do
            envsubst < "$file" | k3s kubectl apply -f -
          done
          
          # Wait briefly for StatefulSets to start pods
          echo "Waiting for StatefulSets to initialize..."
          sleep 10
          
          # Apply PodDisruptionBudgets before deployments
          k3s kubectl apply -f pdbs/
          
          # Apply deployments with env substitution
          for file in deployments/*.yaml; do
            envsubst < "$file" | k3s kubectl apply -f -
          done
          
          echo "Deployments applied. Services will start in background."
          
          echo "All resources applied successfully"

      - name: Check pod status before rollout
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          echo "=== Current Pod Status ==="
          k3s kubectl get pods -n codeclashers
          echo ""
          echo "=== Pod Events (last 20) ==="
          k3s kubectl get events -n codeclashers --sort-by='.lastTimestamp' | tail -20
          echo ""
          echo "=== Node Status ==="
          k3s kubectl describe nodes | grep -A 5 "Allocatable:"
          echo ""
          echo "=== Unscheduleable Pods (if any) ==="
          k3s kubectl get pods -n codeclashers -o wide --field-selector=status.phase=Pending
          k3s kubectl describe pod -n codeclashers mongodb-0 | grep -A 5 Events || true

      - name: Wait for rollouts to complete
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          echo "Waiting for deployments to start..."
          
          # Quick non-blocking check - just wait for pods to exist
          sleep 15
          
          echo "Checking deployment status..."
          k3s kubectl get pods -n codeclashers
          
          echo "Deployments applied. Pods will continue starting in background."

      - name: Verify deployments
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          echo "=== Deployment Status ==="
          k3s kubectl get pods -n codeclashers
          echo ""
          echo "=== Services ==="
          k3s kubectl get svc -n codeclashers
          
      - name: Health check
        env:
          KUBECONFIG: /home/ubuntu/.kube/config
        run: |
          echo "Performing health checks..."
          
          # Wait for Colyseus to be ready
          for i in {1..30}; do
            if k3s kubectl exec -n codeclashers deployment/colyseus -- sh -c "nc -z localhost 2567" 2>/dev/null; then
              echo "âœ“ Colyseus is healthy"
              break
            fi
            sleep 2
          done
          
          # Wait for Judge0 to be ready
          for i in {1..30}; do
            if k3s kubectl exec -n codeclashers deployment/judge0-server -- curl -f http://localhost:2358 >/dev/null 2>&1; then
              echo "âœ“ Judge0 Server is healthy"
              break
            fi
            sleep 2
          done
          
          echo "âœ“ Health checks passed"
          
      - name: Deployment complete
        run: |
          echo "ðŸš€ Deployment complete!"
          echo "Image tag: $IMAGE_TAG"
